#!/usr/bin/ruby

require 'nokogiri'
require 'open-uri'
require 'optparse'
require 'logger'
require 'json'
require 'uri'
require 'pp'

USAGE="usage: #{$0} <convert|i18n_v1|i18n_v2> [opts] <file1> <file2> ... <fileN>"

R_STR=/"[^"]+"/
R_COND=/\s+\w+\s+==\s+(#{R_STR.source})\s+/
R_RAIDCORE_CONVERT=%r{(?:
  ^\s*(?:else)?if#{R_COND.source}(?:(?:and|or)#{R_COND.source})?then\s*
  |^\s*(?:else)?if\s*[a-zA-Z]+(?:\(\))?:find\(\s*(#{R_STR.source})\s*\)
  |^[a-z]+:Register[a-zA-Z]+Objective\(.*\)
  |^[a-z]+:RegisterEnableMob\(
      ((?:\s*#{R_STR.source}\s*,\s*)*)
      \s*(#{R_STR.source})\s*
    \)
  |^[a-z]+:Register[a-zA-Z]+\(
      \s*"[^"]+"\s*,
      ((?:\s*#{R_STR.source}\s*,\s*)*)
      \s*(#{R_STR.source})\s*
    \)
)}x
LANG={en:"enUS", fr:"frFR", de:"deDE"}
SLANG={en: "English", fr: "French", de: "German"}
R_LANG_EN=%r{^\s\[\s*"#{LANG[:en]}"\s*\]}
R_REG_LOCALE={
  en: /^[a-z]+:RegisterEnglishLocale\(/,
  fr: /^[a-z]+:RegisterFrenchLocale\(/,
  de: /^[a-z]+:RegisterGermanLocale\(/,
}
R_RAIDCORE_I18N_V1=/^\s*(\w+)\s*=\s*(#{R_STR.source})/
R_RAIDCORE_I18N_V2=/^\s*\[("([^"]+)")\]\s*=\s*(#{R_STR.source})/

API_SITE='http://wildstar.datminer.com'
API_SEARCH_URL=File.join(API_SITE,'/search/::QUERY::')
API_SEARCH_QUERY=File.join(API_SITE,'/modules/core_search/results_ajax.php'\
  '?filter%5Bstring%5D=::QUERY::&url_language=1')
XPATH_SEARCH_RESULTS="//div[contains(@class,'search-result-title')]/a[@href]"
XPATH_RESULT_NAME="//div[contains(@class,'entity-page-header')]//"\
  "span[contains(@class,'name')]"

#API_SITE='http://www.jabbithole.com'
#API_SEARCH_QUERY=File.join(API_SITE,'/search?q=::QUERY::')
#XPATH_SEARCH_RESULTS="//table[contains(@class,'datalist')]/tbody/tr/td/a[@href]"

$logger = Logger.new($stderr)
$logger.level = Logger::WARN
$logger.formatter = lambda {|lvl,_,_,msg| "[#{lvl}] #{msg}\n"}
$file = nil
$lineno = nil
$noop = false
$nonet = false


def self.errmsg(msg)
  $logger.warn "(#{$file}:#{$lineno}) #{msg}"
end

def self.api_search_url(name,query=true)
  if query
    API_SEARCH_QUERY.gsub(/::QUERY::/,URI.encode(name))
  else
    API_SEARCH_URL.gsub(/::QUERY::/,URI.encode(name))
  end
end

def self.api_result_url(id_path,lang)
  URI.encode(File.join(API_SITE,lang,id_path),'[]{}')
end

def self.select_id(name,links)
  # name exact match
  links.select! do |l|
    l.split(/{|\[/)[0].gsub(/---/,'-') =~ /\/#{name.gsub(/\s/,'-').delete('.')}$/
  end
  $logger.debug("SelectName[#{name}]: #{links.pretty_inspect}")

  # only Spells and NPCs
  links.select!{|l| l =~ /^\/(?:spell|npc)\//}
  $logger.debug("SelectSpellNpc[#{name}]: #{links.pretty_inspect}")

  # TODO: interactive select if more than one result
  $logger.debug("Several choices to translate #{name.inspect}, "\
    "arbitrary picking #{links.first.inspect}") if links.size > 1

  links.first
end

def self.id(name)
  $logger.debug("Fetch[#{name}]: #{api_search_url(name).inspect}")
  return if $nonet
  begin
    doc_search = Nokogiri::HTML(open(api_search_url(name)))
    sleep 0.3
  rescue Exception => e
    abort "Cannot fetch #{api_search_url(name,false)}: #{e.message}"
  end

  res = doc_search.xpath(XPATH_SEARCH_RESULTS)
  if !res or res.empty?
    #errmsg("No reference for '#{name}' (see #{api_search_url(name,false)})")
    return
  end

  res = res.to_a.map!{|l| l['href']}
  $logger.debug("Results[#{name}]: #{res.pretty_inspect}")

  res = select_id(name,res)
  if !res or res.empty?
    #errmsg("No reference for '#{name}' (see #{api_search_url(name,false)})")
    return
  end
  $logger.debug("Path[#{name}]: #{res.inspect}")

  res
end

def self.translate(name,lang)
  return if $nonet
  id = id(name)
  return unless id

  $logger.debug("Fetch[#{name}]: #{api_result_url(name,lang).inspect}")
  begin
    doc_result = Nokogiri::HTML(open(api_result_url(id,lang)))
    sleep 0.3
  rescue Exception => e
    abort "Cannot fetch #{api_result_url(name,lang)}: #{e.message}"
  end

  res = doc_result.xpath(XPATH_RESULT_NAME)

  if !res or res.empty?
    errmsg("No name for '#{name}' (see #{api_result_url(id,lang)})")
    return
  end

  $logger.debug("Translation[#{name}]: #{res.text.inspect}")

  res.text
end


lang = 'fr'
comm = true
dump = false
tfile = nil
ofile = nil

optparse = OptionParser.new(USAGE) do |op|
  op.banner = USAGE
  op.on('-h', '--help', 'Display this screen') do
    $stdout.puts op
    exit
  end
  op.on('-c','--[no-]comment','Add comments to specify the original names') do |c|
    comm = c
  end
  op.on('-d','--dump','Generate a JSON dump of translations') do
    dump = true
  end
  op.on('-l','--lang NAME',['fr','de'],'The output language (default: fr)') do |l|
    lang = l
  end
  op.on('-n','--noop','Do not do not write translations in their files') do
    $noop = true
  end
  op.on('-N','--no-network','Do not download any translations from the network') do
    $nonet = true
  end
  op.on('-o','--output FILE','Dump data in a file') do |f|
    ofile = f
  end
  op.on('-t','--translation-file FILE','Load translations from a file') do |f|
    tfile = f
  end
  op.on('-D','--debug','Debug mode') do
    $logger.level = Logger::DEBUG
  end
  op.on('-v','--verbose','Verbose mode') do
    $logger.level = Logger::INFO
  end
end

begin
  optparse.parse!
rescue OptionParser::MissingArgument,OptionParser::InvalidOption => e
  abort e.message
end

abort USAGE if ARGV.size < 2
abort "Invalid cmd #{ARGV[0]}" unless ARGV[0] =~ /^(?:convert|i18n_v1|i18n_v2)$/


cmd = ARGV[0].to_sym
translations = nil
files = []

if ofile
  if File.exist?(ofile)
    abort "Cannot write file #{ofile}" unless File.writable?(ofile)
  else
    abort "Cannot create file #{ofile}" unless File.writable?(File.dirname(ofile))
  end
end

if tfile
  abort "Cannot read file #{tfile}" unless File.readable?(tfile)
  begin
    translations = JSON.parse(File.read(tfile,encoding: 'utf-8'))
  rescue Exception => e
    abort "Invalid JSON file #{tfile}: #{e.message}"
  end
else
  translations = {}
end

ARGV[1..-1].each do |f|
  abort "Cannot read file #{f}" unless File.readable?(f)

  if File.file?(f)
    files << f
  elsif File.directory?(f)
    files += Dir[File.join(f,'**','*')].to_a
  else
    abort "Not a file or directory #{f}"
  end
end

abort "No files found in #{ARGV[1..-1].join(', ')}" if files.empty?

files.each do |file|
  content = ""
  block_comment = false
  if cmd.to_s =~ /^i18n_/
    i18n_head = nil
    i18n_block = false
    i18n_lvl = 0
  end
  if cmd == :i18n_v1
    i18n_vars = {}
    i18n_block_lang = false
  elsif cmd == :i18n_v2
    i18n_vars = []
  end

  $file = file
  $lineno = 0
  $logger.info("Convert #{file}")

  File.open(file,'r:utf-8').each_line do |line|
    $lineno += 1
    line.chomp!
    comment = nil

    if line =~ /^\s*--\[\[/
      # comment block, don't parse
      block_comment = true
    elsif line =~ /^\s*--\]\]/
      # comment block, don't parse
      block_comment = false
    elsif block_comment
      # comment block, don't parse
    elsif cmd == :convert and line =~ R_RAIDCORE_CONVERT
      names = Regexp.last_match.to_a[1..-1]
      names.compact!
      names.map!{|name| name.scan(/"([^"]+)"/)}.flatten!
      names.delete_if{|name| name =~ /^[A-Z_-]+$/} # constants

      unless names.empty?
        names.inject(translations) do |ret,name|
          # use the cache if possible
          $logger.info("  Translate #{name.inspect} (l.#{$lineno})")
          ret[name] = translations[name] || translate(name,lang)
          errmsg("No reference for '#{name}' (see #{api_search_url(name,false)})") \
            unless ret[name]
          ret
        end

        if cmd == :convert
          comments = []
          names.each do |name|
            if translations[name]
              line.gsub!(/"#{Regexp.escape(name)}"/,"\"#{translations[name]}\"")
              comments << "\"#{name}\""
            else
              comments << "!!! \"#{name}\""
            end
          end
          comment = comments.join(', ')
        end
      end
    elsif cmd == :i18n_v1 and (i18n_block or line =~ R_LANG_EN)
      i18n_head = line.dup unless i18n_block
      i18n_block = true
      i18n_lvl += line.count('{')

      i18n_vars[Regexp.last_match[1]] = {
        name: Regexp.last_match[2],
        line: line.dup,
        lineno: $lineno,
      } if line =~ R_RAIDCORE_I18N_V1

      i18n_lvl -= line.count('}') # FIXME: dirty, does not handle inline

      if i18n_lvl <= 0 # closing }
        i18n_block = false

        content << line
        content << "\r\n"
        content << i18n_head.gsub(LANG[:en],LANG[lang.to_sym])
        content << "\r\n"

        i18n_vars.each do |key,val|
          # use the cache if possible
          name = val[:name].gsub(/"([^"]+)"/,'\1')
          $logger.info("  Translate #{name.inspect} (l.#{val[:lineno]})")
          translations[name] = translate(name,lang) unless translations[name]
          errmsg("No reference for '#{name}' (see #{api_search_url(name,false)})") \
            unless translations[name]

          content << val[:line].gsub(
            /"#{Regexp.escape(name)}"/,
            "\"#{translations[name]||''}\""
          )
          content << "\t-- !!!" if comm and !translations[name]
          content << "\r\n"
        end
      end
    elsif cmd == :i18n_v2 and (i18n_block_lang or line =~ R_REG_LOCALE[lang.to_sym])
      # comment LANG locale if already defined
      # TODO: merge instead of commenting
      content << "-- TODO: to be merged\r\n--[[\r\n" unless i18n_block_lang
      i18n_block_lang = true
      i18n_lvl += line.count('{')

      i18n_lvl -= line.count('}') # FIXME: dirty, does not handle inline

      if i18n_lvl <= 0 # closing }
        i18n_block_lang = false
        content << line
        content << "\r\n"
        line = "--]]\r\n"
      end
    elsif cmd == :i18n_v2 and (i18n_block or line =~ R_REG_LOCALE[:en])
      i18n_head = line.dup unless i18n_block
      i18n_lvl += line.count('{')

      if line =~ R_RAIDCORE_I18N_V2
        i18n_vars << {
          val: Regexp.last_match[1],
          name: Regexp.last_match[2],
          line: line.dup,
          lineno: $lineno,
        }
      elsif i18n_block
        i18n_vars << {
          line: line.dup,
          lineno: $lineno,
        }
      end

      i18n_block = true

      i18n_lvl -= line.count('}') # FIXME: dirty, does not handle inline

      if i18n_lvl <= 0 # closing }
        i18n_block = false

        content << line
        content << "\r\n"
        content << i18n_head.gsub(SLANG[:en],SLANG[lang.to_sym])
        content << "\r\n"
        line = nil

        i18n_vars.each do |var|
          # use the cache if possible
          if var[:name]
            name = var[:name].gsub(/"([^"]+)"/,'\1')
            $logger.info("  Translate #{name.inspect} (l.#{var[:lineno]})")
            translations[name] = translate(name,lang) unless translations[name]
            errmsg("No reference for '#{name}' (see #{api_search_url(name,false)})") \
              unless translations[name]

            content << var[:line].gsub(
              /(=\s*)"[^"]+"/,
              "\\1\"#{translations[name]||name}\""
            )
            content << "\t-- !!!!" if comm and !translations[name]
          else
            content << var[:line]
          end
          content << "\r\n"
        end
      end
    end

    content << line if line
    content << " -- #{comment}" if comm and comment
    content << "\r\n" if line
  end

  File.open(file,'w'){|f| f.write(content)} unless $noop
end

if dump
  dumps = JSON.pretty_generate(translations)
  if ofile
    File.open(ofile,'w'){|f| f.puts dumps}
  else
    $stdout.puts dumps
  end
end
